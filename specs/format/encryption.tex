
Plaintext chunks consist of a 8-byte length field encoding the size of the binary blob accessible through a Merkle structure for which this chunk is the root, followed by the chunk payload which is at most 4096 bytes. Before encrypting, each chunk payload is padded to exactly 4096 bytes, as its actual length can be deduced from the length field as follows:

\begin{lstlisting}

payloadLength := length
while payloadLength > 4096
        payloadLength := payloadLength + 4095
        payloadLength := payloadLength / 4096
        payloadLength := payloadLength * refSize
\end{lstlisting}

Where length is the content of the length field and refSize is the sum of size of the referencing hash value and that of the decryption key, which is currently 64, as we use 256-bit hashes and 256-bit keys.

This procedure can be used to remove the padding after decryption before returning the plaintext chunk. 


It is important to emphasize, that encrypted Swarm chunks are not different from plaintext chunks and therefore no change is needed on the P2P protocol level to accommodate them. The proposed encryption scheme is end-to-end, meaning that encryption and decryption is done on endpoints, i.e., where the http proxy layer runs. This has an important consequence that public gateways cannot be used for encrypted content.

The reference of a single chunk (and the whole content) will be the concatenation of the hash of encrypted data and the decryption key. This means the encrypted  swarm reference (64 bytes) will be longer than the unencrypted one (32 bytes). When a node syncs encrypted chunks, it does not share the full references (or the decryption keys) with the other nodes in any way.  Therefore, other nodes will be unable to access the original data, or in fact, even to detect whether a chunk is encrypted.
        

FIGURE: symmetric encryption in swarm 


The segment keys are generated by hashing the encryption seed with the counter and hash that again. This second step is required so that a segment can be selectively disclosed in a 3rd party provable way yet without compromising the security of the rest of the chunk.

Alternative encryptions of the same chunk can be generated cheaply if the metadata to be prepended to the BMT root hash contains enough entropy.
